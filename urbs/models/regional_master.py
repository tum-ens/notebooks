from .regional_super import *
from ..pyomoio import get_entity


class RegionalMaster(RegionalSuper):
    def __init__(self, data, timesteps=None, dt=1, dual=False, model_type=urbsType.master, site=None, msites=None):
        """Inititates this class as a pyomo ConcreteModel urbs object from given input data.

        Args:
            data: a dict of 6 DataFrames with the keys 'commodity', 'process',
                'transmission', 'storage', 'demand' and 'supim'.
            timesteps: optional list of timesteps, default: demand timeseries
            dt: timestep duration in hours (default: 1)
            dual: set True to add dual variables to model (slower); default: False
            model_type: model_type of the problem; 0: Normal(default), 1:Sub, 2: Master
            site: site of the sub problem
            msites: set of the master problem sites
        """
        super().__init__(data, timesteps, dt, dual, model_type, site, msites)
        # Initialize master model specific things
        self.name = 'urbs-master'
        print(self.name + ' is created.')

        # Sets

        # add cost_type future cost
        self.cost_type.add('FutureCosts')

        # Variables

        # transmission
        self.cap_tra = pyomo.Var(
            self.tra_tuples,
            within=pyomo.NonNegativeReals,
            doc='Total transmission capacity (MW)')
        self.cap_tra_new = pyomo.Var(
            self.tra_tuples,
            within=pyomo.NonNegativeReals,
            doc='New transmission capacity (MW)')

        # Eta Variable
        self.eta = pyomo.Var(
            self.sit,
            within=pyomo.NonNegativeReals,
            bounds=(0.0, None),
            doc='Master Eta')

        # Cut List
        self.Cut_Defn = pyomo.ConstraintList(noruleinit=True)

        for tra in self.tra_tuples:
            self.tra_new[tra].expr = self.cap_tra_new[tra]

        # transmission
        self.def_transmission_capacity = pyomo.Constraint(
            self.tra_tuples,
            rule=def_transmission_capacity_rule,
            doc='total transmission capacity = inst-cap + new capacity')
        self.res_transmission_input_by_capacity = pyomo.Constraint(
            self.tm, self.tra_tuples,
            rule=res_transmission_input_by_capacity_rule,
            doc='transmission input <= total transmission capacity')
        self.res_transmission_capacity = pyomo.Constraint(
            self.tra_tuples,
            rule=res_transmission_capacity_rule,
            doc='transmi2'
                '4s0^1qsion.cap-lo <= total transmission capacity <= '
                'transmission.cap-up')
        self.res_transmission_symmetry = pyomo.Constraint(
            self.tra_tuples,
            rule=res_transmission_symmetry_rule,
            doc='total transmission capacity must be symmetric in both directions')

        # Objective
        self.obj = pyomo.Objective(
            rule=obj_rule,
            sense=pyomo.minimize,
            doc='minimize(cost = sum of all cost types)')

        # Equation Declarations
        # costs
        self.def_costs = pyomo.Constraint(
            self.cost_type,
            rule=def_costs_rule,
            doc='main cost function by cost type')

        self.res_global_co2_limit = pyomo.Constraint(
            rule=res_global_co2_limit_rule,
            doc='total co2 commodity output <= Global CO2 limit')

    def add_cut(self, cut_generating_problem, sub_in_input_files):
        """Adds a cut, which is generated by a subproblem, to the master problem

        Args:
            cut_generating_problem: sub problem instance which generates the cut
            sub_in_input_files: If true, the cut generating problem is in the list of filenames to Excel spread sheets for sub regions
        """
        if cut_generating_problem.Lambda() < 0.000001:
            print('Cut skipped for subproblem ' + cut_generating_problem.sub_site[1] +
                  ' (Lambda = ' + str(cut_generating_problem.Lambda()) + ')')
            return

        # subproblem with input file
        if sub_in_input_files:
            # dual variables
            dual_imp = get_entity(cut_generating_problem, 'res_import')
            dual_exp = get_entity(cut_generating_problem, 'res_export')
            dual_cap = get_entity(cut_generating_problem, 'res_hvac')
            dual_env = get_entity(cut_generating_problem, 'res_global_co2_limit')
            dual_zero = cut_generating_problem.dual[cut_generating_problem.sub_costs]
            Lambda = cut_generating_problem.Lambda()

            cut_expression = - 1 * (sum([dual_imp[tm, tra[0]] * self.e_tra_in[(tm,) + tra]
                                         for tm in self.tm
                                         for tra in self.tra_tuples
                                         if tra[1] == cut_generating_problem.sub_site[1]]) -
                                    sum([dual_exp[tm, tra[1]] * self.e_tra_in[(tm,) + tra]
                                         for tm in self.tm
                                         for tra in self.tra_tuples
                                         if tra[0] == cut_generating_problem.sub_site[1]]) +
                                    sum([dual_cap[tra[0]] * self.cap_tra[tra]
                                         for tra in self.tra_tuples
                                         if tra[1] == cut_generating_problem.sub_site[1]]) +
                                    sum([dual_env[0] * self.e_co_stock[(tm,) + com]
                                         for tm in self.tm
                                         for com in self.com_tuples
                                         if com[0] == cut_generating_problem.sub_site[1] and com[1] in self.com_env]) +
                                    dual_zero * self.eta[cut_generating_problem.sub_site[1]])

        else:
            # dual variables
            dual_tra = get_entity(cut_generating_problem, 'sub_e_tra')
            dual_env = get_entity(cut_generating_problem, 'res_global_co2_limit')
            dual_zero = cut_generating_problem.dual[cut_generating_problem.sub_costs]
            Lambda = cut_generating_problem.Lambda()

            # cut generation
            cut_expression = - 1 * (sum([dual_tra[(tm,) + tra] * self.e_tra_in[(tm,) + tra]
                                         for tm in cut_generating_problem.tm
                                         for tra in cut_generating_problem.tra_tuples
                                         if tra[1] in cut_generating_problem.sub_site]) -
                                    sum([dual_tra[(tm,) + tra] * self.e_tra_in[(tm,) + tra]
                                         for tm in cut_generating_problem.tm
                                         for tra in cut_generating_problem.tra_tuples
                                         if tra[0] in cut_generating_problem.sub_site]) +
                                    sum([dual_env[0] * self.e_co_stock[(tm,) + com]
                                         for tm in cut_generating_problem.tm
                                         for com in cut_generating_problem.com_tuples
                                         if com[1] in cut_generating_problem.com_env]) +
                                    dual_zero * self.eta[cut_generating_problem.sub_site[1]])

        cut = cut_expression >= Lambda + cut_expression()
        self.Cut_Defn.add(cut)


# RegionalMaster specific Constraints

# costs rule for master
# Objective


def def_costs_rule(m, cost_type):
    """Calculate total costs by cost type.

    Sums up process activity and capacity expansions
    and sums them in the cost types that are specified in the set
    m.cost_type. To change or add cost types, add/change entries
    there and modify the if/elif cases in this function accordingly.

    Cost types are
      - Investment costs for process power, storage power and
        storage capacity. They are multiplied by the annuity
        factors.
      - Fixed costs for process power, storage power and storage
        capacity.
      - Variables costs for usage of processes, storage and transmission.
      - Fuel costs for stock commodity purchase.

    """
    if cost_type is 'Invest':
        return m.costs[cost_type] == \
               sum(m.cap_tra_new[t] *
                   m.transmission_dict['inv-cost'][t] *
                   m.transmission_dict['annuity-factor'][t]
                   for t in m.tra_tuples)

    elif cost_type is 'Fixed':
        return m.costs[cost_type] == \
               sum(m.cap_tra[t] * m.transmission_dict['fix-cost'][t]
                   for t in m.tra_tuples)

    elif cost_type is 'Variable':
        return m.costs[cost_type] == \
               sum(m.e_tra_in[(tm,) + t] * m.dt * m.weight *
                   m.transmission_dict['var-cost'][t]
                   for tm in m.tm
                   for t in m.tra_tuples)

    elif cost_type is 'Fuel':
        return m.costs[cost_type] == 0.0

    elif cost_type is 'Environmental':
        return m.costs[cost_type] == 0.0

    elif cost_type == 'FutureCosts':
        return m.costs[cost_type] == sum(m.eta[sit] for sit in m.sit)

    else:
        raise NotImplementedError("Unknown cost type.")
